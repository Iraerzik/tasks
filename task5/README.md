# Проект: Unix Shell на C

## Описание проекта
Простая оболочка командной строки (shell) для Unix-подобных систем, написанная на языке C. Реализует базовые возможности shell, включая выполнение команд, перенаправление ввода/вывода, конвейеры, фоновые процессы и логические операторы.

## Сборка проекта

### Компиляция
```bash
gcc -o shell main.c list.c tree.c exec.c
```

### Запуск
```bash
# Интерактивный режим
./shell

# Режим скрипта
./shell файл_скрипта.txt
```

## Модули проекта

### 1. main.c
Главный модуль, содержащий точку входа в программу.

**Функции:**
- Основной цикл REPL (Read-Eval-Print Loop)
- Обработка ввода пользователя
- Запуск в режиме скрипта или интерактивно
- Обработка сигнала SIGINT (Ctrl+C)

### 2. list.h / list.c
Модуль лексического анализа (токенизации).

**Функции:**
- Разбор входной строки на токены
- Обработка кавычек и экранирования
- Расширение переменных окружения
- Разделение команд по операторам (|, ;, &&, ||, &)
- Поддержка специальных символов: <, >, >>, |, &, ;, (, )

### 3. tree.h / tree.c
Модуль синтаксического анализа и построения AST.

**Функции:**
- Построение абстрактного синтаксического дерева (AST) из списка токенов
- Рекурсивный спуск для разбора выражений
- Поддержка типов узлов:
  - NODE_COMMAND - простая команда
  - NODE_PIPE - конвейер
  - NODE_REDIRECT - перенаправление
  - NODE_BG - фоновая задача
  - NODE_SEQ - последовательность команд
  - NODE_AND / NODE_OR - логические операторы
  - NODE_SUBSHELL - подоболочка

### 4. exec.h / exec.c
Модуль выполнения команд.

**Функции:**
- Выполнение дерева команд
- Управление процессами (fork, exec, wait)
- Реализация конвейеров (pipes)
- Перенаправление ввода/вывода
- Управление фоновыми процессами
- Обработка сигналов (SIGINT, SIGCHLD)

## Возможности shell

### Выполнение команд
```bash
ls -la
echo "текст"
cat файл.txt
```

### Перенаправление ввода/вывода
```bash
# Запись в файл
echo "текст" > файл.txt

# Дописывание в файл
echo "еще текст" >> файл.txt

# Чтение из файла
sort < входные_данные.txt
```

### Конвейеры (pipes)
```bash
ls | grep ".txt"
cat файл.txt | wc -l
ps aux | grep bash | head -5
```

### Логические операторы
```bash
# Выполнить если успешно
ls / && echo "директория существует"

# Выполнить если неуспешно
ls несуществующий || echo "ошибка"
```

### Последовательности команд
```bash
echo "первая"; echo "вторая"; echo "третья"
```

### Фоновое выполнение
```bash
sleep 10 &
long_running_command &
```

### Подоболочки
```bash
(cd /tmp && ls)
(echo "в подоболочке"; pwd)
```

### Переменные окружения
```bash
echo $HOME
echo $PATH
```

## Примеры использования

### Базовые команды
```bash
shell> pwd
shell> ls -l
shell> date
shell> whoami
```

### Комбинации операторов
```bash
shell> ls | grep ".c" && echo "найдены C файлы" || echo "нет C файлов"
shell> (cd /tmp; ls) > список_файлов.txt
shell> find . -name "*.txt" | wc -l &
```

### Сложные конвейеры
```bash
shell> cat /etc/passwd | cut -d: -f1 | sort | uniq | head -10
```

## Ограничения

Не реализовано:
- Встроенные команды (cd, export, history)
- История команд
- Автодополнение
- Подстановка команд через $()
- Шаблоны (wildcards)
- Управление заданиями (jobs, fg, bg)
- Here-documents (<<)

## Формат AST

Дерево строится по следующим правилам:
1. Команда: NODE_COMMAND с аргументами
2. Конвейер: NODE_PIPE с левым и правым поддеревьями
3. Перенаправление: NODE_REDIRECT с именем файла
4. Фоновая задача: NODE_BG с поддеревом для выполнения
5. Последовательность: NODE_SEQ для команд, разделенных ;
6. Логические операторы: NODE_AND / NODE_OR
7. Подоболочка: NODE_SUBSHELL

## Тестирование

### Создание тестового скрипта
```bash
cat > тест.txt << 'EOF'
echo "тест 1"
ls | head -3
echo "завершено"
EOF

./shell тест.txt
```

### Проверка утечек памяти
```bash
valgrind --leak-check=full ./shell
```

## Обработка ошибок

Shell обрабатывает:
- Несуществующие команды (возвращает код 127)
- Ошибки перенаправления (недоступные файлы)
- Синтаксические ошибки (некорректные операторы)
- Прерывание по Ctrl+C

## Структура данных

### BackgroundProcess
Структура для отслеживания фоновых процессов:
```c
typedef struct {
    pid_t pid;           // ID процесса
    char *command;       // имя команды
} BackgroundProcess;
```

### List
Структура для хранения списка токенов:
```c
typedef struct {
    char **lst;          // массив строк
    int sizelist;        // размер массива
    int curlist;         // количество элементов
} List;
```

### Node
Структура узла AST:
```c
struct node {
    char *command;       // команда или оператор
    char **args;         // аргументы команды
    tree left;           // левое поддерево
    tree right;          // правое поддерево
    int type;            // тип узла
};
```

## Порядок выполнения

1. Чтение входной строки
2. Лексический анализ (list.c) → List токенов
3. Синтаксический анализ (tree.c) → AST
4. Выполнение (exec.c) → fork/exec процессов
5. Очистка памяти
